/*
   Copyright (C) 2010 by Sebastian Trueg <trueg@kde.org>

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */

#include "tvdbplugin_config.h"
#include "tvdbexecutivereply.h"
#include "tvdbexecutive.h"
#include "seriescache.h"
#include "tvdbplugin.h"

#include <Soprano/Vocabulary/NAO>
/* These files are generated by nepomuk_add_ontology_classes */
#include "nmm/tvseries.h"
#include "nmm/tvshow.h"

#include "decisionfactory.h"
#include "decision.h"

#include <Nepomuk/Resource>
#include <nepomuk/simpleresource.h>
#include <nepomuk/simpleresourcegraph.h>
#include <KDebug>

Nepomuk::TvdbReply::TvdbReply( TvdbExecutive* parent,
                               const Nepomuk::Decision::DecisionFactory* factory,
                               const Nepomuk::Resource& res,
                               QList<TVShowFilenameAnalyzer::AnalysisResult> candidates 
                             )
    : SimpleExecutiveReply(parent, factory, res)
{
    connect( parent->seriesCache(), SIGNAL( requestDone( int, QList<Tvdb::Series> ) ),
             SLOT(slotRequestDone(int, QList<Tvdb::Series>)) );
    foreach( const TVShowFilenameAnalyzer::AnalysisResult candidate, candidates)
    {
        m_seriesCacheIdSet.insert( 
                parent->seriesCache()->querySeries( candidate.name ),
                candidate
                );
    }
    launched = candidates.size();
}

bool Nepomuk::TvdbReply::isValid() const
{
    return true;
}

void Nepomuk::TvdbReply::abort()
{
    kError() <<  "ATTENTION: Not implemented";
}


void Nepomuk::TvdbReply::slotRequestDone( int id, const QList<Tvdb::Series>& results )
{
    QHash<int, TVShowFilenameAnalyzer::AnalysisResult>::const_iterator fit = 
        m_seriesCacheIdSet.find(id);
    if ( fit != m_seriesCacheIdSet.end() ) {
        kDebug();
        TVShowFilenameAnalyzer::AnalysisResult candidate = fit.value();
        int c_season = candidate.season;
        int c_episode = candidate.episode;
        QString c_name = candidate.name;
        Q_FOREACH( const Tvdb::Series& series, results ) {
            // 1. make sure this series actually has an episode that matches our values
            if ( series.numSeasons() < c_season ||
                 series[c_season].numEpisodes() < c_episode ) {
                kDebug() << "Ignoring" << series.name() << "since it does not contain the requested episode";
                continue;
            }

            kDebug() << "Creating decision for" << series.name();

            // 2. create the new decision
            Nepomuk::Decision::DecisionCreator d = newDecision();

            // 3. create the series resource
            SimpleResource mainResource(resource().resourceUri());
            SimpleResource tvSeries;
            NMM::TVSeries tvSeriesWrapper(&tvSeries);
            tvSeriesWrapper.addPrefLabel(series.name());
            tvSeriesWrapper.addNaoDescription(series.overview());
            /*
            TVSeries tvSeries( QUrl(), d.manager() );
            tvSeries.setLabel( series.name() );
            tvSeries.setDescription( series.overview() );
            */

            // 4. add the data to the file resource: the TVShow type and the rest
            NMM::TVShow tvShowWrapper(&mainResource);
            tvShowWrapper.setEpisodeNumber(c_episode);
            tvShowWrapper.setSeason(c_season);
            tvShowWrapper.setSeries(tvSeries.uri());
            tvShowWrapper.addDescription(series[c_season][c_episode].overview());

            // 5. add data to the tvseries again - circular dependency
            tvSeriesWrapper.addHasEpisode( mainResource.uri() );
            /*
            TVShow proxyRes( d.proxyUrl(resource()), d.manager() );
            proxyRes.addType( QUrl( TVShow::resourceTypeUri() ) );
            proxyRes.setSeries( tvSeries );
            tvSeries.addEpisode( proxyRes );
            proxyRes.setEpisodeNumber( m_episode );
            proxyRes.setSeason( m_season );
            proxyRes.setSynopsis( series[m_season][m_episode].overview() );
            */

            // 5. calculate the probability of the match the dumb way
            d.setRank( TvdbPlugin::calculateRankTheDumbWay( c_name, series.name() ) );

            // 6. add the decision to the temporary pool
            m_cachedDecisions <<  d ;

            // 7. Decrease counter
            launched--;

            if ( launched == 0 ) 
                rankAndSubmit();
        }
    }
}

void Nepomuk::TvdbReply::rankAndSubmit()
{
    if ( m_cachedDecisions.size() > 0 ) {
        foreach( const Nepomuk::Decision::DecisionCreator & creator, m_cachedDecisions)
        {
            // Here must be reranking code. But it is omited for now
        }
    }

    finish();

}
